# List of files and functions

### cleaning\.py:
Program to clean the redundant / unwanted tags returned by the Spoonacular API\.

### Functions:
- clean\(dish, tags\)  : Takes as input, the name of the dish and the tags generated by the API\. Unwanted tags are removed so that the updated set of tags are similar to what is being maintained in the knowledge base\.
- clean\_and\_path\_to\_hier\(dish, tags\)  : Takes the dish and tags as input and stores them in the knowledge base and hierarchy\(?\)

### write\_files\.py:
Contains functions for writing content to dictionary, text file, pickle file, json file\.

### Functions:
- write\_api\_miss\(term, file\_name\)  : takes an item which missed the API\(term\)  and a file name as input parameters\. Checks if the file contains the term and if it does not, appends it to that file
- write\_dict\_json\(key, value, file\_name\)  : takes a json file along with key\-value pair as input\. Checks if the key already exists in the json file\. If yes, its value is appended\. Otherwise, itself is added as its value\(?\) 
- write\_json\(data, file\_name\)  : Input parameters are file name and data\. This function adds the data into the file in json format with proper indentation\.
- write\_to\_dict\(key, tags, file\_name\)  : Takes a file name along with a key\-value pair as input\. Creates a handler which is used to load the pickle file in a user readable format\. Adds the key\-value pair as a dictionary item into the file and dumps it in its original format\(pickle file\) \. Generates logs for each update to the file\.
- write\_to\_list\(full\_list, file\_name\)  : Takes a list as parameter along with a pickle file, as input\. Creates a handler to open the pickle file in write mode and then adds the list to the file and dumps it back as pickle file\.
- log\_data\(message, file\_name\) : Inputs for this function are message and file name\. Any append to the knowledge base, hierarchy, API miss, is logged into a separate file with the timestamp\.

### findleaves\.py:
This program locates the given tags for dish queried in the hierarchy and returns the number of leaves for that particular node\. This is used for scoring the tags proportionately\.

### Functions:
- find\_node\(i, d, dep = 1\) : Input parameters - Node to be found, where it is to be found and the depth is given as 1 by default\. This function finds the node in the hierarchy\.
- find\_leaves\(node, d\) : Takes as input, the node and where it is located\. Returns the number of leaves attached to the node in question\. Returns 1 if there are no leaves\.
- find\_cuisine\_node\(i, d\) : Takes an item along with where it is to be searched, as input and finds its position in the list of cuisines
- find\_shared\_parents\(find\) : Input parameter is an item which is to be checked in the shared parents list\. If it is there, its position in that list is returned\.

### call\_api\.py:
Program to call the Spoonacular API when the queried dish doesn't get matching tags from the knowledge base\.

### Functions:
- get\_list\_from\_file\(file\_name\) : Takes the file in which six API keys are contained, as input.
- api\_call\_count\(\) : Returns the current amount of times the API has been called.
- api\_count\_update\(count\) : Opens the file where the count of API calls exist and updates it by "count"
- call\_api\_tags\(dish\) : Queries the Spoonacular API with the dishes that missed our knowledge base. Each call updates the count of API call by 1. Each call to the API is logged in a separate file. Since each API is limited to 50 calls per day, a count of the API calls are maintained and once it reaches the limit, an error message is thrown and logged. The tags returned by the API are put in a list called "result\_tags" and then are then passed to "cleaning\.py" for those tags to match the format of our knowledge base.

### toPlot\.py: This program is gives the data for plotting graphs which visualises user's old data and the updated data.

### Functions:
- makeDataToPlot\(\) : Retrieves the User ID from a file which maintains the ID of the latest edit. Uses this ID to get that user's old data and new data which is appended in the form an ordered dictionary.